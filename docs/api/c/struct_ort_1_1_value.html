<!-- HTML header for doxygen 1.9.2-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OnnxRuntime: Ort::Value Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-156955408-1"></script><script type="text/javascript">"use strict"; window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-156955408-1'); </script> <script type="text/javascript" src="/assets/js/vendor/lunr.min.js"></script> <script type="text/javascript" src="/assets/js/just-the-docs.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ONNX_Runtime_logo - Docs.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OnnxRuntime
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('struct_ort_1_1_value.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="struct_ort_1_1_value-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Ort::Value Struct Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="onnxruntime__cxx__api_8h_source.html">onnxruntime_cxx_api.h</a>&gt;</code></p>

<p>Inherits <a class="el" href="struct_ort_1_1_base.html">Ort::Base&lt; OrtValue &gt;</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value_1_1_ort_sparse_values_param.html">OrtSparseValuesParam</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value_1_1_shape.html">Shape</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1b6ef55a1a122063d3af38e47c340963"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#a1b6ef55a1a122063d3af38e47c340963">UseCooIndices</a> (int64_t *indices_data, size_t indices_num)</td></tr>
<tr class="memdesc:a1b6ef55a1a122063d3af38e47c340963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supplies COO format specific indices and marks the contained sparse tensor as being a COO format tensor. Values are supplied with a <a class="el" href="struct_ort_1_1_value.html#a07bd3c4da603a8fc23ea6e1f86482f6b" title="This is a simple forwarding method to the other overload that helps deducing data type enum value fro...">CreateSparseTensor()</a> API. The supplied indices are not copied and the user allocated buffers lifespan must eclipse that of the OrtValue. The location of the indices is assumed to be the same as specified by OrtMemoryInfo argument at the creation time.  <a href="struct_ort_1_1_value.html#a1b6ef55a1a122063d3af38e47c340963">More...</a><br /></td></tr>
<tr class="separator:a1b6ef55a1a122063d3af38e47c340963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a475c1d0e4610b9ace64a71c938fd64d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#a475c1d0e4610b9ace64a71c938fd64d2">UseCsrIndices</a> (int64_t *inner_data, size_t inner_num, int64_t *outer_data, size_t outer_num)</td></tr>
<tr class="memdesc:a475c1d0e4610b9ace64a71c938fd64d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supplies CSR format specific indices and marks the contained sparse tensor as being a CSR format tensor. Values are supplied with a <a class="el" href="struct_ort_1_1_value.html#a07bd3c4da603a8fc23ea6e1f86482f6b" title="This is a simple forwarding method to the other overload that helps deducing data type enum value fro...">CreateSparseTensor()</a> API. The supplied indices are not copied and the user allocated buffers lifespan must eclipse that of the OrtValue. The location of the indices is assumed to be the same as specified by OrtMemoryInfo argument at the creation time.  <a href="struct_ort_1_1_value.html#a475c1d0e4610b9ace64a71c938fd64d2">More...</a><br /></td></tr>
<tr class="separator:a475c1d0e4610b9ace64a71c938fd64d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f8b5207913f0c484bc14ee7518ff17e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#a8f8b5207913f0c484bc14ee7518ff17e">UseBlockSparseIndices</a> (const <a class="el" href="struct_ort_1_1_value_1_1_shape.html">Shape</a> &amp;indices_shape, int32_t *indices_data)</td></tr>
<tr class="memdesc:a8f8b5207913f0c484bc14ee7518ff17e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supplies BlockSparse format specific indices and marks the contained sparse tensor as being a BlockSparse format tensor. Values are supplied with a <a class="el" href="struct_ort_1_1_value.html#a07bd3c4da603a8fc23ea6e1f86482f6b" title="This is a simple forwarding method to the other overload that helps deducing data type enum value fro...">CreateSparseTensor()</a> API. The supplied indices are not copied and the user allocated buffers lifespan must eclipse that of the OrtValue. The location of the indices is assumed to be the same as specified by OrtMemoryInfo argument at the creation time.  <a href="struct_ort_1_1_value.html#a8f8b5207913f0c484bc14ee7518ff17e">More...</a><br /></td></tr>
<tr class="separator:a8f8b5207913f0c484bc14ee7518ff17e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa938f89369a0754d673d57c30ca15a07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#aa938f89369a0754d673d57c30ca15a07">FillSparseTensorCoo</a> (const <a class="el" href="group___global.html#ga088f45e429651ac29b4a9efb4d88571a">OrtMemoryInfo</a> *data_mem_info, const <a class="el" href="struct_ort_1_1_value_1_1_ort_sparse_values_param.html">OrtSparseValuesParam</a> &amp;values_param, const int64_t *indices_data, size_t indices_num)</td></tr>
<tr class="memdesc:aa938f89369a0754d673d57c30ca15a07"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API will allocate memory using the allocator instance supplied to the <a class="el" href="struct_ort_1_1_value.html#a07bd3c4da603a8fc23ea6e1f86482f6b" title="This is a simple forwarding method to the other overload that helps deducing data type enum value fro...">CreateSparseTensor()</a> API and copy the values and COO indices into it. If data_mem_info specifies that the data is located at difference device than the allocator, a X-device copy will be performed if possible.  <a href="struct_ort_1_1_value.html#aa938f89369a0754d673d57c30ca15a07">More...</a><br /></td></tr>
<tr class="separator:aa938f89369a0754d673d57c30ca15a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb67431539beec2b8229be2924ff0cc6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#adb67431539beec2b8229be2924ff0cc6">FillSparseTensorCsr</a> (const <a class="el" href="group___global.html#ga088f45e429651ac29b4a9efb4d88571a">OrtMemoryInfo</a> *data_mem_info, const <a class="el" href="struct_ort_1_1_value_1_1_ort_sparse_values_param.html">OrtSparseValuesParam</a> &amp;values, const int64_t *inner_indices_data, size_t inner_indices_num, const int64_t *outer_indices_data, size_t outer_indices_num)</td></tr>
<tr class="memdesc:adb67431539beec2b8229be2924ff0cc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API will allocate memory using the allocator instance supplied to the <a class="el" href="struct_ort_1_1_value.html#a07bd3c4da603a8fc23ea6e1f86482f6b" title="This is a simple forwarding method to the other overload that helps deducing data type enum value fro...">CreateSparseTensor()</a> API and copy the values and CSR indices into it. If data_mem_info specifies that the data is located at difference device than the allocator, a X-device copy will be performed if possible.  <a href="struct_ort_1_1_value.html#adb67431539beec2b8229be2924ff0cc6">More...</a><br /></td></tr>
<tr class="separator:adb67431539beec2b8229be2924ff0cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a969cce2f5429f038ffe9662538e484b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#a969cce2f5429f038ffe9662538e484b5">FillSparseTensorBlockSparse</a> (const <a class="el" href="group___global.html#ga088f45e429651ac29b4a9efb4d88571a">OrtMemoryInfo</a> *data_mem_info, const <a class="el" href="struct_ort_1_1_value_1_1_ort_sparse_values_param.html">OrtSparseValuesParam</a> &amp;values, const <a class="el" href="struct_ort_1_1_value_1_1_shape.html">Shape</a> &amp;indices_shape, const int32_t *indices_data)</td></tr>
<tr class="memdesc:a969cce2f5429f038ffe9662538e484b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API will allocate memory using the allocator instance supplied to the <a class="el" href="struct_ort_1_1_value.html#a07bd3c4da603a8fc23ea6e1f86482f6b" title="This is a simple forwarding method to the other overload that helps deducing data type enum value fro...">CreateSparseTensor()</a> API and copy the values and BlockSparse indices into it. If data_mem_info specifies that the data is located at difference device than the allocator, a X-device copy will be performed if possible.  <a href="struct_ort_1_1_value.html#a969cce2f5429f038ffe9662538e484b5">More...</a><br /></td></tr>
<tr class="separator:a969cce2f5429f038ffe9662538e484b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb0f62eb042c6bf25f023331fbf821f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___global.html#gaba2697542109e4ab6b24a8fbb847812d">OrtSparseFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#afb0f62eb042c6bf25f023331fbf821f1">GetSparseFormat</a> () const</td></tr>
<tr class="memdesc:afb0f62eb042c6bf25f023331fbf821f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API returns the sparse data format this OrtValue holds in a sparse tensor. If the sparse tensor was not fully constructed, i.e. Use*() or Fill*() API were not used the value returned is ORT_SPARSE_UNDEFINED.  <a href="struct_ort_1_1_value.html#afb0f62eb042c6bf25f023331fbf821f1">More...</a><br /></td></tr>
<tr class="separator:afb0f62eb042c6bf25f023331fbf821f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c671843b4a34071311d7d5ce7af38d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ort_1_1_tensor_type_and_shape_info.html">TensorTypeAndShapeInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#a8c671843b4a34071311d7d5ce7af38d9">GetSparseTensorValuesTypeAndShapeInfo</a> () const</td></tr>
<tr class="memdesc:a8c671843b4a34071311d7d5ce7af38d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API returns type and shape information for stored non-zero values of the sparse tensor. Use <a class="el" href="struct_ort_1_1_value.html#af6f22b4c04a4b8182bf0b3c1da334c84" title="The API returns a pointer to an internal buffer of the sparse tensor containing non-zero values....">GetSparseTensorValues()</a> to obtain values buffer pointer.  <a href="struct_ort_1_1_value.html#a8c671843b4a34071311d7d5ce7af38d9">More...</a><br /></td></tr>
<tr class="separator:a8c671843b4a34071311d7d5ce7af38d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fafbe9098011d60978cfe9f7c9b7083"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ort_1_1_tensor_type_and_shape_info.html">TensorTypeAndShapeInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#a6fafbe9098011d60978cfe9f7c9b7083">GetSparseTensorIndicesTypeShapeInfo</a> (<a class="el" href="group___global.html#ga497c04502f658b896b265233fc890787">OrtSparseIndicesFormat</a> format) const</td></tr>
<tr class="memdesc:a6fafbe9098011d60978cfe9f7c9b7083"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API returns type and shape information for the specified indices. Each supported indices have their own enum values even if a give format has more than one kind of indices. Use <a class="el" href="struct_ort_1_1_value.html#a0eaf1f9f96f18194ead77ee855698503" title="The API retrieves a pointer to the internal indices buffer. The API merely performs a convenience dat...">GetSparseTensorIndicesData()</a> to obtain pointer to indices buffer.  <a href="struct_ort_1_1_value.html#a6fafbe9098011d60978cfe9f7c9b7083">More...</a><br /></td></tr>
<tr class="separator:a6fafbe9098011d60978cfe9f7c9b7083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eaf1f9f96f18194ead77ee855698503"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0eaf1f9f96f18194ead77ee855698503"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#a0eaf1f9f96f18194ead77ee855698503">GetSparseTensorIndicesData</a> (<a class="el" href="group___global.html#ga497c04502f658b896b265233fc890787">OrtSparseIndicesFormat</a> indices_format, size_t &amp;num_indices) const</td></tr>
<tr class="memdesc:a0eaf1f9f96f18194ead77ee855698503"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API retrieves a pointer to the internal indices buffer. The API merely performs a convenience data type casting on the return type pointer. Make sure you are requesting the right type, use <a class="el" href="struct_ort_1_1_value.html#a6fafbe9098011d60978cfe9f7c9b7083" title="The API returns type and shape information for the specified indices. Each supported indices have the...">GetSparseTensorIndicesTypeShapeInfo()</a>;  <a href="struct_ort_1_1_value.html#a0eaf1f9f96f18194ead77ee855698503">More...</a><br /></td></tr>
<tr class="separator:a0eaf1f9f96f18194ead77ee855698503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8813a399df6e6576923c1c40d39c67e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af8813a399df6e6576923c1c40d39c67e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#af8813a399df6e6576923c1c40d39c67e">GetOpaqueData</a> (const char *domain, const char *type_name, T &amp;) const</td></tr>
<tr class="memdesc:af8813a399df6e6576923c1c40d39c67e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps <a class="el" href="struct_ort_api.html#aab40422beeb98330f90cf758eaba36a7" title="Get internal data from an opaque (custom user defined type) OrtValue.">OrtApi::GetOpaqueValue</a>.  <a href="struct_ort_1_1_value.html#af8813a399df6e6576923c1c40d39c67e">More...</a><br /></td></tr>
<tr class="separator:af8813a399df6e6576923c1c40d39c67e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a233d9a9878a69295ad504ea2b22b4d1f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#a233d9a9878a69295ad504ea2b22b4d1f">Value</a> (std::nullptr_t)</td></tr>
<tr class="memdesc:a233d9a9878a69295ad504ea2b22b4d1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an empty <a class="el" href="struct_ort_1_1_value.html">Value</a> object, must be assigned a valid one to be used.  <a href="struct_ort_1_1_value.html#a233d9a9878a69295ad504ea2b22b4d1f">More...</a><br /></td></tr>
<tr class="separator:a233d9a9878a69295ad504ea2b22b4d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e744a54c1fe6c477cccbe33b580fe3b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#a4e744a54c1fe6c477cccbe33b580fe3b">Value</a> (<a class="el" href="group___global.html#gaab167acf3fe9dabc0195b993fbe7ee7d">OrtValue</a> *p)</td></tr>
<tr class="memdesc:a4e744a54c1fe6c477cccbe33b580fe3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for interop with the C API.  <a href="struct_ort_1_1_value.html#a4e744a54c1fe6c477cccbe33b580fe3b">More...</a><br /></td></tr>
<tr class="separator:a4e744a54c1fe6c477cccbe33b580fe3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7884f57758a06ca3b1203fcff98a08"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#a1b7884f57758a06ca3b1203fcff98a08">Value</a> (<a class="el" href="struct_ort_1_1_value.html">Value</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a1b7884f57758a06ca3b1203fcff98a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ce9c0a1b41a61eb0f94bc9070539eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ort_1_1_value.html">Value</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#a14ce9c0a1b41a61eb0f94bc9070539eb">operator=</a> (<a class="el" href="struct_ort_1_1_value.html">Value</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a14ce9c0a1b41a61eb0f94bc9070539eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2df13bf81010090da46eee36c4a9b5a4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#a2df13bf81010090da46eee36c4a9b5a4">IsTensor</a> () const</td></tr>
<tr class="memdesc:a2df13bf81010090da46eee36c4a9b5a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <a class="el" href="struct_ort_1_1_value.html">Value</a> is a tensor, false for other types like map/sequence/etc.  <a href="struct_ort_1_1_value.html#a2df13bf81010090da46eee36c4a9b5a4">More...</a><br /></td></tr>
<tr class="separator:a2df13bf81010090da46eee36c4a9b5a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4d6700f1e1d961b02a39c2a43689ad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#acf4d6700f1e1d961b02a39c2a43689ad">HasValue</a> () const</td></tr>
<tr class="separator:acf4d6700f1e1d961b02a39c2a43689ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6db197c9c78aafe5b1a6f4e1e5d743dc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#a6db197c9c78aafe5b1a6f4e1e5d743dc">IsSparseTensor</a> () const</td></tr>
<tr class="memdesc:a6db197c9c78aafe5b1a6f4e1e5d743dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt; Return true if OrtValue contains data and returns false if the OrtValue is a None  <a href="struct_ort_1_1_value.html#a6db197c9c78aafe5b1a6f4e1e5d743dc">More...</a><br /></td></tr>
<tr class="separator:a6db197c9c78aafe5b1a6f4e1e5d743dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67248a12bf88d9093c18f719cf45b934"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#a67248a12bf88d9093c18f719cf45b934">GetCount</a> () const</td></tr>
<tr class="separator:a67248a12bf88d9093c18f719cf45b934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1dd63c5d27e40ef9836f276a8b94dec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ort_1_1_value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#ac1dd63c5d27e40ef9836f276a8b94dec">GetValue</a> (int index, <a class="el" href="struct_ort_allocator.html">OrtAllocator</a> *allocator) const</td></tr>
<tr class="separator:ac1dd63c5d27e40ef9836f276a8b94dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd9c45362170384c33eccdbf1ab1fa87"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#afd9c45362170384c33eccdbf1ab1fa87">GetStringTensorDataLength</a> () const</td></tr>
<tr class="memdesc:afd9c45362170384c33eccdbf1ab1fa87"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API returns a full length of string data contained within either a tensor or a sparse Tensor. For sparse tensor it returns a full length of stored non-empty strings (values). The API is useful for allocating necessary memory and calling <a class="el" href="struct_ort_1_1_value.html#a50a029dee567f88be916994cc14da4b3" title="The API copies all of the UTF-8 encoded string data contained within a tensor or a sparse tensor into...">GetStringTensorContent()</a>.  <a href="struct_ort_1_1_value.html#afd9c45362170384c33eccdbf1ab1fa87">More...</a><br /></td></tr>
<tr class="separator:afd9c45362170384c33eccdbf1ab1fa87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50a029dee567f88be916994cc14da4b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#a50a029dee567f88be916994cc14da4b3">GetStringTensorContent</a> (void *buffer, size_t buffer_length, size_t *offsets, size_t offsets_count) const</td></tr>
<tr class="memdesc:a50a029dee567f88be916994cc14da4b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API copies all of the UTF-8 encoded string data contained within a tensor or a sparse tensor into a supplied buffer. Use <a class="el" href="struct_ort_1_1_value.html#afd9c45362170384c33eccdbf1ab1fa87" title="This API returns a full length of string data contained within either a tensor or a sparse Tensor....">GetStringTensorDataLength()</a> to find out the length of the buffer to allocate. The user must also allocate offsets buffer with the number of entries equal to that of the contained strings.  <a href="struct_ort_1_1_value.html#a50a029dee567f88be916994cc14da4b3">More...</a><br /></td></tr>
<tr class="separator:a50a029dee567f88be916994cc14da4b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a008fc5074d15a9af5a971de7dd8834ac"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a008fc5074d15a9af5a971de7dd8834ac"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#a008fc5074d15a9af5a971de7dd8834ac">GetTensorMutableData</a> ()</td></tr>
<tr class="memdesc:a008fc5074d15a9af5a971de7dd8834ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps <a class="el" href="struct_ort_api.html#a24486475cc05b9228a57b814b2024d77" title="Get a pointer to the raw data inside a tensor.">OrtApi::GetTensorMutableData</a>.  <a href="struct_ort_1_1_value.html#a008fc5074d15a9af5a971de7dd8834ac">More...</a><br /></td></tr>
<tr class="separator:a008fc5074d15a9af5a971de7dd8834ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c4cc546773ba410659bb67ea5a6c10"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a35c4cc546773ba410659bb67ea5a6c10"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#a35c4cc546773ba410659bb67ea5a6c10">GetTensorData</a> () const</td></tr>
<tr class="memdesc:a35c4cc546773ba410659bb67ea5a6c10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps <a class="el" href="struct_ort_api.html#a24486475cc05b9228a57b814b2024d77" title="Get a pointer to the raw data inside a tensor.">OrtApi::GetTensorMutableData</a>.  <a href="struct_ort_1_1_value.html#a35c4cc546773ba410659bb67ea5a6c10">More...</a><br /></td></tr>
<tr class="separator:a35c4cc546773ba410659bb67ea5a6c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f22b4c04a4b8182bf0b3c1da334c84"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af6f22b4c04a4b8182bf0b3c1da334c84"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#af6f22b4c04a4b8182bf0b3c1da334c84">GetSparseTensorValues</a> () const</td></tr>
<tr class="memdesc:af6f22b4c04a4b8182bf0b3c1da334c84"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API returns a pointer to an internal buffer of the sparse tensor containing non-zero values. The API merely does casting. Make sure you are requesting the right data type by calling <a class="el" href="struct_ort_1_1_value.html#a8c671843b4a34071311d7d5ce7af38d9" title="The API returns type and shape information for stored non-zero values of the sparse tensor....">GetSparseTensorValuesTypeAndShapeInfo()</a> first.  <a href="struct_ort_1_1_value.html#af6f22b4c04a4b8182bf0b3c1da334c84">More...</a><br /></td></tr>
<tr class="separator:af6f22b4c04a4b8182bf0b3c1da334c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9823fe23891528c075f2d5ddc4b45efc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9823fe23891528c075f2d5ddc4b45efc"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#a9823fe23891528c075f2d5ddc4b45efc">At</a> (const std::vector&lt; int64_t &gt; &amp;location)</td></tr>
<tr class="separator:a9823fe23891528c075f2d5ddc4b45efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a568ff40447e756b3a62ec7c903b45e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ort_1_1_type_info.html">TypeInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#a9a568ff40447e756b3a62ec7c903b45e">GetTypeInfo</a> () const</td></tr>
<tr class="memdesc:a9a568ff40447e756b3a62ec7c903b45e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API returns type information for data contained in a tensor. For sparse tensors it returns type information for contained non-zero values. It returns dense shape for sparse tensors.  <a href="struct_ort_1_1_value.html#a9a568ff40447e756b3a62ec7c903b45e">More...</a><br /></td></tr>
<tr class="separator:a9a568ff40447e756b3a62ec7c903b45e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe6e43ecc5679d3e547183f36248c9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ort_1_1_tensor_type_and_shape_info.html">TensorTypeAndShapeInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#a3fe6e43ecc5679d3e547183f36248c9d">GetTensorTypeAndShapeInfo</a> () const</td></tr>
<tr class="memdesc:a3fe6e43ecc5679d3e547183f36248c9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API returns type information for data contained in a tensor. For sparse tensors it returns type information for contained non-zero values. It returns dense shape for sparse tensors.  <a href="struct_ort_1_1_value.html#a3fe6e43ecc5679d3e547183f36248c9d">More...</a><br /></td></tr>
<tr class="separator:a3fe6e43ecc5679d3e547183f36248c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759a2a4e0c3c37dd0d164e60ce3ae301"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#a759a2a4e0c3c37dd0d164e60ce3ae301">GetStringTensorElementLength</a> (size_t element_index) const</td></tr>
<tr class="memdesc:a759a2a4e0c3c37dd0d164e60ce3ae301"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API returns a byte length of UTF-8 encoded string element contained in either a tensor or a spare tensor values.  <a href="struct_ort_1_1_value.html#a759a2a4e0c3c37dd0d164e60ce3ae301">More...</a><br /></td></tr>
<tr class="separator:a759a2a4e0c3c37dd0d164e60ce3ae301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad50d9f9c09d7305d37b51b9dc71001c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#ad50d9f9c09d7305d37b51b9dc71001c3">GetStringTensorElement</a> (size_t buffer_length, size_t element_index, void *buffer) const</td></tr>
<tr class="memdesc:ad50d9f9c09d7305d37b51b9dc71001c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API copies UTF-8 encoded bytes for the requested string element contained within a tensor or a sparse tensor into a provided buffer. Use <a class="el" href="struct_ort_1_1_value.html#a759a2a4e0c3c37dd0d164e60ce3ae301" title="The API returns a byte length of UTF-8 encoded string element contained in either a tensor or a spare...">GetStringTensorElementLength()</a> to obtain the length of the buffer to allocate.  <a href="struct_ort_1_1_value.html#ad50d9f9c09d7305d37b51b9dc71001c3">More...</a><br /></td></tr>
<tr class="separator:ad50d9f9c09d7305d37b51b9dc71001c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a939aa860fb784dd7a2d47bdd8eecb294"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#a939aa860fb784dd7a2d47bdd8eecb294">FillStringTensor</a> (const char *const *s, size_t s_len)</td></tr>
<tr class="separator:a939aa860fb784dd7a2d47bdd8eecb294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae733e1a8c0bfbb7667f5ce1a2db90d17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#ae733e1a8c0bfbb7667f5ce1a2db90d17">FillStringTensorElement</a> (const char *s, size_t index)</td></tr>
<tr class="separator:ae733e1a8c0bfbb7667f5ce1a2db90d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_struct_ort_1_1_base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_struct_ort_1_1_base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="struct_ort_1_1_base.html">Ort::Base&lt; OrtValue &gt;</a></td></tr>
<tr class="memitem:a66d10ddc7737be4e09ec0936f4268fef inherit pub_methods_struct_ort_1_1_base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_base.html#a66d10ddc7737be4e09ec0936f4268fef">Base</a> ()=default</td></tr>
<tr class="separator:a66d10ddc7737be4e09ec0936f4268fef inherit pub_methods_struct_ort_1_1_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac871a942635518ffed7ba564c6a8f52e inherit pub_methods_struct_ort_1_1_base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_base.html#ac871a942635518ffed7ba564c6a8f52e">Base</a> (<a class="el" href="group___global.html#gaab167acf3fe9dabc0195b993fbe7ee7d">OrtValue</a> *p)</td></tr>
<tr class="separator:ac871a942635518ffed7ba564c6a8f52e inherit pub_methods_struct_ort_1_1_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4596ebf9650803a86a84a1bc04cd78af inherit pub_methods_struct_ort_1_1_base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_base.html#a4596ebf9650803a86a84a1bc04cd78af">~Base</a> ()</td></tr>
<tr class="separator:a4596ebf9650803a86a84a1bc04cd78af inherit pub_methods_struct_ort_1_1_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b1270f1fe2a1242d89ad7ff31ea0523 inherit pub_methods_struct_ort_1_1_base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_base.html#a4b1270f1fe2a1242d89ad7ff31ea0523">operator OrtValue *</a> ()</td></tr>
<tr class="separator:a4b1270f1fe2a1242d89ad7ff31ea0523 inherit pub_methods_struct_ort_1_1_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82c7f161984cf2803c17ae85bbd66176 inherit pub_methods_struct_ort_1_1_base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_base.html#a82c7f161984cf2803c17ae85bbd66176">operator const OrtValue *</a> () const</td></tr>
<tr class="separator:a82c7f161984cf2803c17ae85bbd66176 inherit pub_methods_struct_ort_1_1_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f4ae170cb8adebc982cb2dea39325c9 inherit pub_methods_struct_ort_1_1_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___global.html#gaab167acf3fe9dabc0195b993fbe7ee7d">OrtValue</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_base.html#a2f4ae170cb8adebc982cb2dea39325c9">release</a> ()</td></tr>
<tr class="memdesc:a2f4ae170cb8adebc982cb2dea39325c9 inherit pub_methods_struct_ort_1_1_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases ownership of the contained pointer.  <a href="struct_ort_1_1_base.html#a2f4ae170cb8adebc982cb2dea39325c9">More...</a><br /></td></tr>
<tr class="separator:a2f4ae170cb8adebc982cb2dea39325c9 inherit pub_methods_struct_ort_1_1_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a3898146b5fc35b838bd48db807dd6c8e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3898146b5fc35b838bd48db807dd6c8e"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="struct_ort_1_1_value.html">Value</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#a3898146b5fc35b838bd48db807dd6c8e">CreateTensor</a> (const <a class="el" href="group___global.html#ga088f45e429651ac29b4a9efb4d88571a">OrtMemoryInfo</a> *info, T *p_data, size_t p_data_element_count, const int64_t *shape, size_t shape_len)</td></tr>
<tr class="memdesc:a3898146b5fc35b838bd48db807dd6c8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a tensor with a user supplied buffer. Wraps <a class="el" href="struct_ort_api.html#a2aad3ccd68c66d0b38bdb966467d9324" title="Create a tensor backed by a user supplied buffer.">OrtApi::CreateTensorWithDataAsOrtValue</a>.  <a href="struct_ort_1_1_value.html#a3898146b5fc35b838bd48db807dd6c8e">More...</a><br /></td></tr>
<tr class="separator:a3898146b5fc35b838bd48db807dd6c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19ff01babfb77660ed022c4057046ef"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_ort_1_1_value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#ab19ff01babfb77660ed022c4057046ef">CreateTensor</a> (const <a class="el" href="group___global.html#ga088f45e429651ac29b4a9efb4d88571a">OrtMemoryInfo</a> *info, void *p_data, size_t p_data_byte_count, const int64_t *shape, size_t shape_len, <a class="el" href="group___global.html#gaec63cdda46c29b8183997f38930ce38e">ONNXTensorElementDataType</a> type)</td></tr>
<tr class="memdesc:ab19ff01babfb77660ed022c4057046ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a tensor with a user supplied buffer. Wraps <a class="el" href="struct_ort_api.html#a2aad3ccd68c66d0b38bdb966467d9324" title="Create a tensor backed by a user supplied buffer.">OrtApi::CreateTensorWithDataAsOrtValue</a>.  <a href="struct_ort_1_1_value.html#ab19ff01babfb77660ed022c4057046ef">More...</a><br /></td></tr>
<tr class="separator:ab19ff01babfb77660ed022c4057046ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07bd3c4da603a8fc23ea6e1f86482f6b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a07bd3c4da603a8fc23ea6e1f86482f6b"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="struct_ort_1_1_value.html">Value</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#a07bd3c4da603a8fc23ea6e1f86482f6b">CreateSparseTensor</a> (const <a class="el" href="group___global.html#ga088f45e429651ac29b4a9efb4d88571a">OrtMemoryInfo</a> *info, T *p_data, const <a class="el" href="struct_ort_1_1_value_1_1_shape.html">Shape</a> &amp;dense_shape, const <a class="el" href="struct_ort_1_1_value_1_1_shape.html">Shape</a> &amp;values_shape)</td></tr>
<tr class="memdesc:a07bd3c4da603a8fc23ea6e1f86482f6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a simple forwarding method to the other overload that helps deducing data type enum value from the type of the buffer.  <a href="struct_ort_1_1_value.html#a07bd3c4da603a8fc23ea6e1f86482f6b">More...</a><br /></td></tr>
<tr class="separator:a07bd3c4da603a8fc23ea6e1f86482f6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a059315bd22476066e30a2d6034bfb9d3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_ort_1_1_value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#a059315bd22476066e30a2d6034bfb9d3">CreateSparseTensor</a> (const <a class="el" href="group___global.html#ga088f45e429651ac29b4a9efb4d88571a">OrtMemoryInfo</a> *info, void *p_data, const <a class="el" href="struct_ort_1_1_value_1_1_shape.html">Shape</a> &amp;dense_shape, const <a class="el" href="struct_ort_1_1_value_1_1_shape.html">Shape</a> &amp;values_shape, <a class="el" href="group___global.html#gaec63cdda46c29b8183997f38930ce38e">ONNXTensorElementDataType</a> type)</td></tr>
<tr class="memdesc:a059315bd22476066e30a2d6034bfb9d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an OrtValue instance containing SparseTensor. This constructs a sparse tensor that makes use of user allocated buffers. It does not make copies of the user provided data and does not modify it. The lifespan of user provided buffers should eclipse the life span of the resulting OrtValue. This call constructs an instance that only contain a pointer to non-zero values. To fully populate the sparse tensor call Use&lt;Format&gt;Indices() API below to supply a sparse format specific indices. This API is not suitable for string data. Use <a class="el" href="struct_ort_1_1_value.html#a07bd3c4da603a8fc23ea6e1f86482f6b" title="This is a simple forwarding method to the other overload that helps deducing data type enum value fro...">CreateSparseTensor()</a> with allocator specified so strings can be properly copied into the allocated buffer.  <a href="struct_ort_1_1_value.html#a059315bd22476066e30a2d6034bfb9d3">More...</a><br /></td></tr>
<tr class="separator:a059315bd22476066e30a2d6034bfb9d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acacfe668acf9b55ffcd9d375c7f32053"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acacfe668acf9b55ffcd9d375c7f32053"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="struct_ort_1_1_value.html">Value</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#acacfe668acf9b55ffcd9d375c7f32053">CreateTensor</a> (<a class="el" href="struct_ort_allocator.html">OrtAllocator</a> *allocator, const int64_t *shape, size_t shape_len)</td></tr>
<tr class="memdesc:acacfe668acf9b55ffcd9d375c7f32053"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a tensor using a supplied <a class="el" href="struct_ort_allocator.html" title="Memory allocation interface.">OrtAllocator</a>. Wraps <a class="el" href="struct_ort_api.html#afa229d9d92820cc59298ed38d3f4f73f" title="Create a tensor.">OrtApi::CreateTensorAsOrtValue</a>.  <a href="struct_ort_1_1_value.html#acacfe668acf9b55ffcd9d375c7f32053">More...</a><br /></td></tr>
<tr class="separator:acacfe668acf9b55ffcd9d375c7f32053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d35080239ae47cdbc9e505666dc32ec"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_ort_1_1_value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#a5d35080239ae47cdbc9e505666dc32ec">CreateTensor</a> (<a class="el" href="struct_ort_allocator.html">OrtAllocator</a> *allocator, const int64_t *shape, size_t shape_len, <a class="el" href="group___global.html#gaec63cdda46c29b8183997f38930ce38e">ONNXTensorElementDataType</a> type)</td></tr>
<tr class="memdesc:a5d35080239ae47cdbc9e505666dc32ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a tensor using a supplied <a class="el" href="struct_ort_allocator.html" title="Memory allocation interface.">OrtAllocator</a>. Wraps <a class="el" href="struct_ort_api.html#afa229d9d92820cc59298ed38d3f4f73f" title="Create a tensor.">OrtApi::CreateTensorAsOrtValue</a>.  <a href="struct_ort_1_1_value.html#a5d35080239ae47cdbc9e505666dc32ec">More...</a><br /></td></tr>
<tr class="separator:a5d35080239ae47cdbc9e505666dc32ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a560452c9940a9756089e42d767932e46"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a560452c9940a9756089e42d767932e46"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="struct_ort_1_1_value.html">Value</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#a560452c9940a9756089e42d767932e46">CreateSparseTensor</a> (<a class="el" href="struct_ort_allocator.html">OrtAllocator</a> *allocator, const <a class="el" href="struct_ort_1_1_value_1_1_shape.html">Shape</a> &amp;dense_shape)</td></tr>
<tr class="memdesc:a560452c9940a9756089e42d767932e46"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a simple forwarding method the below CreateSparseTensor. This helps to specify data type enum in terms of C++ data type. Use CreateSparseTensor&lt;T&gt;  <a href="struct_ort_1_1_value.html#a560452c9940a9756089e42d767932e46">More...</a><br /></td></tr>
<tr class="separator:a560452c9940a9756089e42d767932e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15ae05c786194af9ba2e541a91233b2f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_ort_1_1_value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#a15ae05c786194af9ba2e541a91233b2f">CreateSparseTensor</a> (<a class="el" href="struct_ort_allocator.html">OrtAllocator</a> *allocator, const <a class="el" href="struct_ort_1_1_value_1_1_shape.html">Shape</a> &amp;dense_shape, <a class="el" href="group___global.html#gaec63cdda46c29b8183997f38930ce38e">ONNXTensorElementDataType</a> type)</td></tr>
<tr class="memdesc:a15ae05c786194af9ba2e541a91233b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of OrtValue containing sparse tensor. The created instance has no data. The data must be supplied by on of the FillSparseTensor&lt;Format&gt;() methods that take both non-zero values and indices. The data will be copied into a buffer that would be allocated using the supplied allocator. Use this API to create OrtValues that contain sparse tensors with all supported data types including strings.  <a href="struct_ort_1_1_value.html#a15ae05c786194af9ba2e541a91233b2f">More...</a><br /></td></tr>
<tr class="separator:a15ae05c786194af9ba2e541a91233b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028498f12d19f373b7479abe8a4a8b75"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_ort_1_1_value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#a028498f12d19f373b7479abe8a4a8b75">CreateMap</a> (<a class="el" href="struct_ort_1_1_value.html">Value</a> &amp;keys, <a class="el" href="struct_ort_1_1_value.html">Value</a> &amp;values)</td></tr>
<tr class="memdesc:a028498f12d19f373b7479abe8a4a8b75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps <a class="el" href="struct_ort_api.html#ac0a58d7d43a98ebe44a2d2f7f8406415" title="Create a map or sequence OrtValue.">OrtApi::CreateValue</a>.  <a href="struct_ort_1_1_value.html#a028498f12d19f373b7479abe8a4a8b75">More...</a><br /></td></tr>
<tr class="separator:a028498f12d19f373b7479abe8a4a8b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ca9c86f4996e9490e7e9de960f7afc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_ort_1_1_value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#ad4ca9c86f4996e9490e7e9de960f7afc">CreateSequence</a> (std::vector&lt; <a class="el" href="struct_ort_1_1_value.html">Value</a> &gt; &amp;values)</td></tr>
<tr class="memdesc:ad4ca9c86f4996e9490e7e9de960f7afc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps <a class="el" href="struct_ort_api.html#ac0a58d7d43a98ebe44a2d2f7f8406415" title="Create a map or sequence OrtValue.">OrtApi::CreateValue</a>.  <a href="struct_ort_1_1_value.html#ad4ca9c86f4996e9490e7e9de960f7afc">More...</a><br /></td></tr>
<tr class="separator:ad4ca9c86f4996e9490e7e9de960f7afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba8bad055b8cdaa1fb57f9aba9e6773e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aba8bad055b8cdaa1fb57f9aba9e6773e"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="struct_ort_1_1_value.html">Value</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_value.html#aba8bad055b8cdaa1fb57f9aba9e6773e">CreateOpaque</a> (const char *domain, const char *type_name, const T &amp;)</td></tr>
<tr class="memdesc:aba8bad055b8cdaa1fb57f9aba9e6773e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps <a class="el" href="struct_ort_api.html#ae12e59921f2c3480bb4bc0fcf7ddd6ec" title="Create an opaque (custom user defined type) OrtValue.">OrtApi::CreateOpaqueValue</a>.  <a href="struct_ort_1_1_value.html#aba8bad055b8cdaa1fb57f9aba9e6773e">More...</a><br /></td></tr>
<tr class="separator:aba8bad055b8cdaa1fb57f9aba9e6773e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_struct_ort_1_1_base"><td colspan="2" onclick="javascript:toggleInherit('pub_types_struct_ort_1_1_base')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="struct_ort_1_1_base.html">Ort::Base&lt; OrtValue &gt;</a></td></tr>
<tr class="memitem:aea8ad8947b663fdcc1b81f129912e79e inherit pub_types_struct_ort_1_1_base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_base.html#aea8ad8947b663fdcc1b81f129912e79e">contained_type</a> = <a class="el" href="group___global.html#gaab167acf3fe9dabc0195b993fbe7ee7d">OrtValue</a></td></tr>
<tr class="separator:aea8ad8947b663fdcc1b81f129912e79e inherit pub_types_struct_ort_1_1_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_struct_ort_1_1_base"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_struct_ort_1_1_base')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="struct_ort_1_1_base.html">Ort::Base&lt; OrtValue &gt;</a></td></tr>
<tr class="memitem:abe0c053fd682decf4149f7d788d6b9ed inherit pro_methods_struct_ort_1_1_base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_base.html#abe0c053fd682decf4149f7d788d6b9ed">Base</a> (const <a class="el" href="struct_ort_1_1_base.html">Base</a> &amp;)=delete</td></tr>
<tr class="separator:abe0c053fd682decf4149f7d788d6b9ed inherit pro_methods_struct_ort_1_1_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da2e4fc1874f3ec50c34ec5954d7be1 inherit pro_methods_struct_ort_1_1_base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_base.html#a9da2e4fc1874f3ec50c34ec5954d7be1">Base</a> (<a class="el" href="struct_ort_1_1_base.html">Base</a> &amp;&amp;v) noexcept</td></tr>
<tr class="separator:a9da2e4fc1874f3ec50c34ec5954d7be1 inherit pro_methods_struct_ort_1_1_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2517f75e3511fd84579f99502bf39b1e inherit pro_methods_struct_ort_1_1_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_ort_1_1_base.html">Base</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_base.html#a2517f75e3511fd84579f99502bf39b1e">operator=</a> (const <a class="el" href="struct_ort_1_1_base.html">Base</a> &amp;)=delete</td></tr>
<tr class="separator:a2517f75e3511fd84579f99502bf39b1e inherit pro_methods_struct_ort_1_1_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c3f4684de3e03acecaefd82b5e516b inherit pro_methods_struct_ort_1_1_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_base.html#ae1c3f4684de3e03acecaefd82b5e516b">operator=</a> (<a class="el" href="struct_ort_1_1_base.html">Base</a> &amp;&amp;v) noexcept</td></tr>
<tr class="separator:ae1c3f4684de3e03acecaefd82b5e516b inherit pro_methods_struct_ort_1_1_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_struct_ort_1_1_base"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_struct_ort_1_1_base')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="struct_ort_1_1_base.html">Ort::Base&lt; OrtValue &gt;</a></td></tr>
<tr class="memitem:ab6424ea36bd85db866473e004a6915e5 inherit pro_attribs_struct_ort_1_1_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___global.html#gaab167acf3fe9dabc0195b993fbe7ee7d">OrtValue</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ort_1_1_base.html#ab6424ea36bd85db866473e004a6915e5">p_</a></td></tr>
<tr class="separator:ab6424ea36bd85db866473e004a6915e5 inherit pro_attribs_struct_ort_1_1_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a233d9a9878a69295ad504ea2b22b4d1f" name="a233d9a9878a69295ad504ea2b22b4d1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a233d9a9878a69295ad504ea2b22b4d1f">&#9670;&nbsp;</a></span>Value() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ort::Value::Value </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an empty <a class="el" href="struct_ort_1_1_value.html">Value</a> object, must be assigned a valid one to be used. </p>

</div>
</div>
<a id="a4e744a54c1fe6c477cccbe33b580fe3b" name="a4e744a54c1fe6c477cccbe33b580fe3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e744a54c1fe6c477cccbe33b580fe3b">&#9670;&nbsp;</a></span>Value() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ort::Value::Value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___global.html#gaab167acf3fe9dabc0195b993fbe7ee7d">OrtValue</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used for interop with the C API. </p>

</div>
</div>
<a id="a1b7884f57758a06ca3b1203fcff98a08" name="a1b7884f57758a06ca3b1203fcff98a08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b7884f57758a06ca3b1203fcff98a08">&#9670;&nbsp;</a></span>Value() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ort::Value::Value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ort_1_1_value.html">Value</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9823fe23891528c075f2d5ddc4b45efc" name="a9823fe23891528c075f2d5ddc4b45efc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9823fe23891528c075f2d5ddc4b45efc">&#9670;&nbsp;</a></span>At()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T &amp; Ort::Value::At </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>location</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a028498f12d19f373b7479abe8a4a8b75" name="a028498f12d19f373b7479abe8a4a8b75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a028498f12d19f373b7479abe8a4a8b75">&#9670;&nbsp;</a></span>CreateMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_ort_1_1_value.html">Value</a> Ort::Value::CreateMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ort_1_1_value.html">Value</a> &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ort_1_1_value.html">Value</a> &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps <a class="el" href="struct_ort_api.html#ac0a58d7d43a98ebe44a2d2f7f8406415" title="Create a map or sequence OrtValue.">OrtApi::CreateValue</a>. </p>

</div>
</div>
<a id="aba8bad055b8cdaa1fb57f9aba9e6773e" name="aba8bad055b8cdaa1fb57f9aba9e6773e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba8bad055b8cdaa1fb57f9aba9e6773e">&#9670;&nbsp;</a></span>CreateOpaque()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_ort_1_1_value.html">Value</a> Ort::Value::CreateOpaque </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>type_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps <a class="el" href="struct_ort_api.html#ae12e59921f2c3480bb4bc0fcf7ddd6ec" title="Create an opaque (custom user defined type) OrtValue.">OrtApi::CreateOpaqueValue</a>. </p>

</div>
</div>
<a id="ad4ca9c86f4996e9490e7e9de960f7afc" name="ad4ca9c86f4996e9490e7e9de960f7afc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4ca9c86f4996e9490e7e9de960f7afc">&#9670;&nbsp;</a></span>CreateSequence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_ort_1_1_value.html">Value</a> Ort::Value::CreateSequence </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_ort_1_1_value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps <a class="el" href="struct_ort_api.html#ac0a58d7d43a98ebe44a2d2f7f8406415" title="Create a map or sequence OrtValue.">OrtApi::CreateValue</a>. </p>

</div>
</div>
<a id="a07bd3c4da603a8fc23ea6e1f86482f6b" name="a07bd3c4da603a8fc23ea6e1f86482f6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07bd3c4da603a8fc23ea6e1f86482f6b">&#9670;&nbsp;</a></span>CreateSparseTensor() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_ort_1_1_value.html">Value</a> Ort::Value::CreateSparseTensor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___global.html#ga088f45e429651ac29b4a9efb4d88571a">OrtMemoryInfo</a> *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ort_1_1_value_1_1_shape.html">Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>dense_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ort_1_1_value_1_1_shape.html">Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>values_shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a simple forwarding method to the other overload that helps deducing data type enum value from the type of the buffer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>numeric datatype. This API is not suitable for strings.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>Memory description where the user buffers reside (CPU vs GPU etc)</td></tr>
    <tr><td class="paramname">p_data</td><td>pointer to the user supplied buffer, use nullptr for fully sparse tensors</td></tr>
    <tr><td class="paramname">dense_shape</td><td>a would be dense shape of the tensor</td></tr>
    <tr><td class="paramname">values_shape</td><td>non zero values shape. Use a single 0 shape for fully sparse tensors.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a059315bd22476066e30a2d6034bfb9d3" name="a059315bd22476066e30a2d6034bfb9d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a059315bd22476066e30a2d6034bfb9d3">&#9670;&nbsp;</a></span>CreateSparseTensor() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_ort_1_1_value.html">Value</a> Ort::Value::CreateSparseTensor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___global.html#ga088f45e429651ac29b4a9efb4d88571a">OrtMemoryInfo</a> *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ort_1_1_value_1_1_shape.html">Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>dense_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ort_1_1_value_1_1_shape.html">Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>values_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___global.html#gaec63cdda46c29b8183997f38930ce38e">ONNXTensorElementDataType</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an OrtValue instance containing SparseTensor. This constructs a sparse tensor that makes use of user allocated buffers. It does not make copies of the user provided data and does not modify it. The lifespan of user provided buffers should eclipse the life span of the resulting OrtValue. This call constructs an instance that only contain a pointer to non-zero values. To fully populate the sparse tensor call Use&lt;Format&gt;Indices() API below to supply a sparse format specific indices. This API is not suitable for string data. Use <a class="el" href="struct_ort_1_1_value.html#a07bd3c4da603a8fc23ea6e1f86482f6b" title="This is a simple forwarding method to the other overload that helps deducing data type enum value fro...">CreateSparseTensor()</a> with allocator specified so strings can be properly copied into the allocated buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>Memory description where the user buffers reside (CPU vs GPU etc)</td></tr>
    <tr><td class="paramname">p_data</td><td>pointer to the user supplied buffer, use nullptr for fully sparse tensors</td></tr>
    <tr><td class="paramname">dense_shape</td><td>a would be dense shape of the tensor</td></tr>
    <tr><td class="paramname">values_shape</td><td>non zero values shape. Use a single 0 shape for fully sparse tensors.</td></tr>
    <tr><td class="paramname">type</td><td>data type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_ort_1_1_value.html">Ort::Value</a> instance containing SparseTensor</dd></dl>

</div>
</div>
<a id="a560452c9940a9756089e42d767932e46" name="a560452c9940a9756089e42d767932e46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a560452c9940a9756089e42d767932e46">&#9670;&nbsp;</a></span>CreateSparseTensor() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_ort_1_1_value.html">Value</a> Ort::Value::CreateSparseTensor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ort_allocator.html">OrtAllocator</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ort_1_1_value_1_1_shape.html">Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>dense_shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a simple forwarding method the below CreateSparseTensor. This helps to specify data type enum in terms of C++ data type. Use CreateSparseTensor&lt;T&gt; </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>numeric data type only. String data enum must be specified explicitly.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>allocator to use</td></tr>
    <tr><td class="paramname">dense_shape</td><td>a would be dense shape of the tensor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_ort_1_1_value.html">Ort::Value</a></dd></dl>

</div>
</div>
<a id="a15ae05c786194af9ba2e541a91233b2f" name="a15ae05c786194af9ba2e541a91233b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15ae05c786194af9ba2e541a91233b2f">&#9670;&nbsp;</a></span>CreateSparseTensor() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_ort_1_1_value.html">Value</a> Ort::Value::CreateSparseTensor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ort_allocator.html">OrtAllocator</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ort_1_1_value_1_1_shape.html">Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>dense_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___global.html#gaec63cdda46c29b8183997f38930ce38e">ONNXTensorElementDataType</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an instance of OrtValue containing sparse tensor. The created instance has no data. The data must be supplied by on of the FillSparseTensor&lt;Format&gt;() methods that take both non-zero values and indices. The data will be copied into a buffer that would be allocated using the supplied allocator. Use this API to create OrtValues that contain sparse tensors with all supported data types including strings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>allocator to use. The allocator lifespan must eclipse that of the resulting OrtValue</td></tr>
    <tr><td class="paramname">dense_shape</td><td>a would be dense shape of the tensor</td></tr>
    <tr><td class="paramname">type</td><td>data type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an instance of <a class="el" href="struct_ort_1_1_value.html">Ort::Value</a></dd></dl>

</div>
</div>
<a id="a3898146b5fc35b838bd48db807dd6c8e" name="a3898146b5fc35b838bd48db807dd6c8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3898146b5fc35b838bd48db807dd6c8e">&#9670;&nbsp;</a></span>CreateTensor() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_ort_1_1_value.html">Value</a> Ort::Value::CreateTensor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___global.html#ga088f45e429651ac29b4a9efb4d88571a">OrtMemoryInfo</a> *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>p_data_element_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t *&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>shape_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a tensor with a user supplied buffer. Wraps <a class="el" href="struct_ort_api.html#a2aad3ccd68c66d0b38bdb966467d9324" title="Create a tensor backed by a user supplied buffer.">OrtApi::CreateTensorWithDataAsOrtValue</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The numeric datatype. This API is not suitable for strings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>Memory description of where the p_data buffer resides (CPU vs GPU etc). </td></tr>
    <tr><td class="paramname">p_data</td><td>Pointer to the data buffer. </td></tr>
    <tr><td class="paramname">p_data_element_count</td><td>The number of elements in the data buffer. </td></tr>
    <tr><td class="paramname">shape</td><td>Pointer to the tensor shape dimensions. </td></tr>
    <tr><td class="paramname">shape_len</td><td>The number of tensor shape dimensions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab19ff01babfb77660ed022c4057046ef" name="ab19ff01babfb77660ed022c4057046ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab19ff01babfb77660ed022c4057046ef">&#9670;&nbsp;</a></span>CreateTensor() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_ort_1_1_value.html">Value</a> Ort::Value::CreateTensor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___global.html#ga088f45e429651ac29b4a9efb4d88571a">OrtMemoryInfo</a> *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>p_data_byte_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t *&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>shape_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___global.html#gaec63cdda46c29b8183997f38930ce38e">ONNXTensorElementDataType</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a tensor with a user supplied buffer. Wraps <a class="el" href="struct_ort_api.html#a2aad3ccd68c66d0b38bdb966467d9324" title="Create a tensor backed by a user supplied buffer.">OrtApi::CreateTensorWithDataAsOrtValue</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>Memory description of where the p_data buffer resides (CPU vs GPU etc). </td></tr>
    <tr><td class="paramname">p_data</td><td>Pointer to the data buffer. </td></tr>
    <tr><td class="paramname">p_data_byte_count</td><td>The number of bytes in the data buffer. </td></tr>
    <tr><td class="paramname">shape</td><td>Pointer to the tensor shape dimensions. </td></tr>
    <tr><td class="paramname">shape_len</td><td>The number of tensor shape dimensions. </td></tr>
    <tr><td class="paramname">type</td><td>The data type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acacfe668acf9b55ffcd9d375c7f32053" name="acacfe668acf9b55ffcd9d375c7f32053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acacfe668acf9b55ffcd9d375c7f32053">&#9670;&nbsp;</a></span>CreateTensor() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_ort_1_1_value.html">Value</a> Ort::Value::CreateTensor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ort_allocator.html">OrtAllocator</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t *&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>shape_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a tensor using a supplied <a class="el" href="struct_ort_allocator.html" title="Memory allocation interface.">OrtAllocator</a>. Wraps <a class="el" href="struct_ort_api.html#afa229d9d92820cc59298ed38d3f4f73f" title="Create a tensor.">OrtApi::CreateTensorAsOrtValue</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The numeric datatype. This API is not suitable for strings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>The allocator to use. </td></tr>
    <tr><td class="paramname">shape</td><td>Pointer to the tensor shape dimensions. </td></tr>
    <tr><td class="paramname">shape_len</td><td>The number of tensor shape dimensions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d35080239ae47cdbc9e505666dc32ec" name="a5d35080239ae47cdbc9e505666dc32ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d35080239ae47cdbc9e505666dc32ec">&#9670;&nbsp;</a></span>CreateTensor() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_ort_1_1_value.html">Value</a> Ort::Value::CreateTensor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ort_allocator.html">OrtAllocator</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t *&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>shape_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___global.html#gaec63cdda46c29b8183997f38930ce38e">ONNXTensorElementDataType</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a tensor using a supplied <a class="el" href="struct_ort_allocator.html" title="Memory allocation interface.">OrtAllocator</a>. Wraps <a class="el" href="struct_ort_api.html#afa229d9d92820cc59298ed38d3f4f73f" title="Create a tensor.">OrtApi::CreateTensorAsOrtValue</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>The allocator to use. </td></tr>
    <tr><td class="paramname">shape</td><td>Pointer to the tensor shape dimensions. </td></tr>
    <tr><td class="paramname">shape_len</td><td>The number of tensor shape dimensions. </td></tr>
    <tr><td class="paramname">type</td><td>The data type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a969cce2f5429f038ffe9662538e484b5" name="a969cce2f5429f038ffe9662538e484b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a969cce2f5429f038ffe9662538e484b5">&#9670;&nbsp;</a></span>FillSparseTensorBlockSparse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ort::Value::FillSparseTensorBlockSparse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___global.html#ga088f45e429651ac29b4a9efb4d88571a">OrtMemoryInfo</a> *&#160;</td>
          <td class="paramname"><em>data_mem_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ort_1_1_value_1_1_ort_sparse_values_param.html">OrtSparseValuesParam</a> &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ort_1_1_value_1_1_shape.html">Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>indices_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t *&#160;</td>
          <td class="paramname"><em>indices_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The API will allocate memory using the allocator instance supplied to the <a class="el" href="struct_ort_1_1_value.html#a07bd3c4da603a8fc23ea6e1f86482f6b" title="This is a simple forwarding method to the other overload that helps deducing data type enum value fro...">CreateSparseTensor()</a> API and copy the values and BlockSparse indices into it. If data_mem_info specifies that the data is located at difference device than the allocator, a X-device copy will be performed if possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_mem_info</td><td>specified buffer memory description</td></tr>
    <tr><td class="paramname">values</td><td>values buffer information</td></tr>
    <tr><td class="paramname">indices_shape</td><td>indices shape. use {0} for fully sparse tensors</td></tr>
    <tr><td class="paramname">indices_data</td><td>pointer to indices data or nullptr for fully sparse tensors</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa938f89369a0754d673d57c30ca15a07" name="aa938f89369a0754d673d57c30ca15a07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa938f89369a0754d673d57c30ca15a07">&#9670;&nbsp;</a></span>FillSparseTensorCoo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ort::Value::FillSparseTensorCoo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___global.html#ga088f45e429651ac29b4a9efb4d88571a">OrtMemoryInfo</a> *&#160;</td>
          <td class="paramname"><em>data_mem_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ort_1_1_value_1_1_ort_sparse_values_param.html">OrtSparseValuesParam</a> &amp;&#160;</td>
          <td class="paramname"><em>values_param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t *&#160;</td>
          <td class="paramname"><em>indices_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>indices_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The API will allocate memory using the allocator instance supplied to the <a class="el" href="struct_ort_1_1_value.html#a07bd3c4da603a8fc23ea6e1f86482f6b" title="This is a simple forwarding method to the other overload that helps deducing data type enum value fro...">CreateSparseTensor()</a> API and copy the values and COO indices into it. If data_mem_info specifies that the data is located at difference device than the allocator, a X-device copy will be performed if possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_mem_info</td><td>specified buffer memory description</td></tr>
    <tr><td class="paramname">values_param</td><td>values buffer information.</td></tr>
    <tr><td class="paramname">indices_data</td><td>coo indices buffer or nullptr for fully sparse data</td></tr>
    <tr><td class="paramname">indices_num</td><td>number of COO indices or 0 for fully sparse data</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb67431539beec2b8229be2924ff0cc6" name="adb67431539beec2b8229be2924ff0cc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb67431539beec2b8229be2924ff0cc6">&#9670;&nbsp;</a></span>FillSparseTensorCsr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ort::Value::FillSparseTensorCsr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___global.html#ga088f45e429651ac29b4a9efb4d88571a">OrtMemoryInfo</a> *&#160;</td>
          <td class="paramname"><em>data_mem_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_ort_1_1_value_1_1_ort_sparse_values_param.html">OrtSparseValuesParam</a> &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t *&#160;</td>
          <td class="paramname"><em>inner_indices_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>inner_indices_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t *&#160;</td>
          <td class="paramname"><em>outer_indices_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>outer_indices_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The API will allocate memory using the allocator instance supplied to the <a class="el" href="struct_ort_1_1_value.html#a07bd3c4da603a8fc23ea6e1f86482f6b" title="This is a simple forwarding method to the other overload that helps deducing data type enum value fro...">CreateSparseTensor()</a> API and copy the values and CSR indices into it. If data_mem_info specifies that the data is located at difference device than the allocator, a X-device copy will be performed if possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_mem_info</td><td>specified buffer memory description</td></tr>
    <tr><td class="paramname">values</td><td>values buffer information</td></tr>
    <tr><td class="paramname">inner_indices_data</td><td>csr inner indices pointer or nullptr for fully sparse tensors</td></tr>
    <tr><td class="paramname">inner_indices_num</td><td>number of csr inner indices or 0 for fully sparse tensors</td></tr>
    <tr><td class="paramname">outer_indices_data</td><td>pointer to csr indices data or nullptr for fully sparse tensors</td></tr>
    <tr><td class="paramname">outer_indices_num</td><td>number of csr outer indices or 0</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a939aa860fb784dd7a2d47bdd8eecb294" name="a939aa860fb784dd7a2d47bdd8eecb294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a939aa860fb784dd7a2d47bdd8eecb294">&#9670;&nbsp;</a></span>FillStringTensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ort::Value::FillStringTensor </td>
          <td>(</td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>s_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae733e1a8c0bfbb7667f5ce1a2db90d17" name="ae733e1a8c0bfbb7667f5ce1a2db90d17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae733e1a8c0bfbb7667f5ce1a2db90d17">&#9670;&nbsp;</a></span>FillStringTensorElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ort::Value::FillStringTensorElement </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a67248a12bf88d9093c18f719cf45b934" name="a67248a12bf88d9093c18f719cf45b934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67248a12bf88d9093c18f719cf45b934">&#9670;&nbsp;</a></span>GetCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ort::Value::GetCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af8813a399df6e6576923c1c40d39c67e" name="af8813a399df6e6576923c1c40d39c67e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8813a399df6e6576923c1c40d39c67e">&#9670;&nbsp;</a></span>GetOpaqueData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Ort::Value::GetOpaqueData </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>type_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps <a class="el" href="struct_ort_api.html#aab40422beeb98330f90cf758eaba36a7" title="Get internal data from an opaque (custom user defined type) OrtValue.">OrtApi::GetOpaqueValue</a>. </p>

</div>
</div>
<a id="afb0f62eb042c6bf25f023331fbf821f1" name="afb0f62eb042c6bf25f023331fbf821f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb0f62eb042c6bf25f023331fbf821f1">&#9670;&nbsp;</a></span>GetSparseFormat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___global.html#gaba2697542109e4ab6b24a8fbb847812d">OrtSparseFormat</a> Ort::Value::GetSparseFormat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The API returns the sparse data format this OrtValue holds in a sparse tensor. If the sparse tensor was not fully constructed, i.e. Use*() or Fill*() API were not used the value returned is ORT_SPARSE_UNDEFINED. </p>
<dl class="section return"><dt>Returns</dt><dd>Format enum</dd></dl>

</div>
</div>
<a id="a0eaf1f9f96f18194ead77ee855698503" name="a0eaf1f9f96f18194ead77ee855698503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eaf1f9f96f18194ead77ee855698503">&#9670;&nbsp;</a></span>GetSparseTensorIndicesData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T * Ort::Value::GetSparseTensorIndicesData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___global.html#ga497c04502f658b896b265233fc890787">OrtSparseIndicesFormat</a>&#160;</td>
          <td class="paramname"><em>indices_format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>num_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The API retrieves a pointer to the internal indices buffer. The API merely performs a convenience data type casting on the return type pointer. Make sure you are requesting the right type, use <a class="el" href="struct_ort_1_1_value.html#a6fafbe9098011d60978cfe9f7c9b7083" title="The API returns type and shape information for the specified indices. Each supported indices have the...">GetSparseTensorIndicesTypeShapeInfo()</a>; </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type to cast to</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices_format</td><td>requested indices kind</td></tr>
    <tr><td class="paramname">num_indices</td><td>number of indices entries</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pinter to the internal sparse tensor buffer containing indices. Do not free this pointer.</dd></dl>

</div>
</div>
<a id="a6fafbe9098011d60978cfe9f7c9b7083" name="a6fafbe9098011d60978cfe9f7c9b7083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fafbe9098011d60978cfe9f7c9b7083">&#9670;&nbsp;</a></span>GetSparseTensorIndicesTypeShapeInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ort_1_1_tensor_type_and_shape_info.html">TensorTypeAndShapeInfo</a> Ort::Value::GetSparseTensorIndicesTypeShapeInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___global.html#ga497c04502f658b896b265233fc890787">OrtSparseIndicesFormat</a>&#160;</td>
          <td class="paramname"><em>format</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The API returns type and shape information for the specified indices. Each supported indices have their own enum values even if a give format has more than one kind of indices. Use <a class="el" href="struct_ort_1_1_value.html#a0eaf1f9f96f18194ead77ee855698503" title="The API retrieves a pointer to the internal indices buffer. The API merely performs a convenience dat...">GetSparseTensorIndicesData()</a> to obtain pointer to indices buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>enum requested</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>type and shape information</dd></dl>

</div>
</div>
<a id="af6f22b4c04a4b8182bf0b3c1da334c84" name="af6f22b4c04a4b8182bf0b3c1da334c84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6f22b4c04a4b8182bf0b3c1da334c84">&#9670;&nbsp;</a></span>GetSparseTensorValues()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T * Ort::Value::GetSparseTensorValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The API returns a pointer to an internal buffer of the sparse tensor containing non-zero values. The API merely does casting. Make sure you are requesting the right data type by calling <a class="el" href="struct_ort_1_1_value.html#a8c671843b4a34071311d7d5ce7af38d9" title="The API returns type and shape information for stored non-zero values of the sparse tensor....">GetSparseTensorValuesTypeAndShapeInfo()</a> first. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>numeric data types only. Use GetStringTensor*() to retrieve strings.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the internal values buffer. Do not free this pointer.</dd></dl>

</div>
</div>
<a id="a8c671843b4a34071311d7d5ce7af38d9" name="a8c671843b4a34071311d7d5ce7af38d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c671843b4a34071311d7d5ce7af38d9">&#9670;&nbsp;</a></span>GetSparseTensorValuesTypeAndShapeInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ort_1_1_tensor_type_and_shape_info.html">TensorTypeAndShapeInfo</a> Ort::Value::GetSparseTensorValuesTypeAndShapeInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The API returns type and shape information for stored non-zero values of the sparse tensor. Use <a class="el" href="struct_ort_1_1_value.html#af6f22b4c04a4b8182bf0b3c1da334c84" title="The API returns a pointer to an internal buffer of the sparse tensor containing non-zero values....">GetSparseTensorValues()</a> to obtain values buffer pointer. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_ort_1_1_tensor_type_and_shape_info.html" title="Wrapper around OrtTensorTypeAndShapeInfo.">TensorTypeAndShapeInfo</a> values information</dd></dl>

</div>
</div>
<a id="a50a029dee567f88be916994cc14da4b3" name="a50a029dee567f88be916994cc14da4b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50a029dee567f88be916994cc14da4b3">&#9670;&nbsp;</a></span>GetStringTensorContent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ort::Value::GetStringTensorContent </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buffer_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offsets_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The API copies all of the UTF-8 encoded string data contained within a tensor or a sparse tensor into a supplied buffer. Use <a class="el" href="struct_ort_1_1_value.html#afd9c45362170384c33eccdbf1ab1fa87" title="This API returns a full length of string data contained within either a tensor or a sparse Tensor....">GetStringTensorDataLength()</a> to find out the length of the buffer to allocate. The user must also allocate offsets buffer with the number of entries equal to that of the contained strings. </p>
<p >Strings are always assumed to be on CPU, no X-device copy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>user allocated buffer</td></tr>
    <tr><td class="paramname">buffer_length</td><td>length in bytes of the allocated buffer</td></tr>
    <tr><td class="paramname">offsets</td><td>a pointer to the offsets user allocated buffer</td></tr>
    <tr><td class="paramname">offsets_count</td><td>count of offsets, must be equal to the number of strings contained. that can be obtained from the shape of the tensor or from <a class="el" href="struct_ort_1_1_value.html#a8c671843b4a34071311d7d5ce7af38d9" title="The API returns type and shape information for stored non-zero values of the sparse tensor....">GetSparseTensorValuesTypeAndShapeInfo()</a> for sparse tensors</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd9c45362170384c33eccdbf1ab1fa87" name="afd9c45362170384c33eccdbf1ab1fa87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd9c45362170384c33eccdbf1ab1fa87">&#9670;&nbsp;</a></span>GetStringTensorDataLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ort::Value::GetStringTensorDataLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API returns a full length of string data contained within either a tensor or a sparse Tensor. For sparse tensor it returns a full length of stored non-empty strings (values). The API is useful for allocating necessary memory and calling <a class="el" href="struct_ort_1_1_value.html#a50a029dee567f88be916994cc14da4b3" title="The API copies all of the UTF-8 encoded string data contained within a tensor or a sparse tensor into...">GetStringTensorContent()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>total length of UTF-8 encoded bytes contained. No zero terminators counted.</dd></dl>

</div>
</div>
<a id="ad50d9f9c09d7305d37b51b9dc71001c3" name="ad50d9f9c09d7305d37b51b9dc71001c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad50d9f9c09d7305d37b51b9dc71001c3">&#9670;&nbsp;</a></span>GetStringTensorElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ort::Value::GetStringTensorElement </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buffer_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>element_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The API copies UTF-8 encoded bytes for the requested string element contained within a tensor or a sparse tensor into a provided buffer. Use <a class="el" href="struct_ort_1_1_value.html#a759a2a4e0c3c37dd0d164e60ce3ae301" title="The API returns a byte length of UTF-8 encoded string element contained in either a tensor or a spare...">GetStringTensorElementLength()</a> to obtain the length of the buffer to allocate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer_length</td><td></td></tr>
    <tr><td class="paramname">element_index</td><td></td></tr>
    <tr><td class="paramname">buffer</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a759a2a4e0c3c37dd0d164e60ce3ae301" name="a759a2a4e0c3c37dd0d164e60ce3ae301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a759a2a4e0c3c37dd0d164e60ce3ae301">&#9670;&nbsp;</a></span>GetStringTensorElementLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ort::Value::GetStringTensorElementLength </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>element_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The API returns a byte length of UTF-8 encoded string element contained in either a tensor or a spare tensor values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element_index</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>byte length for the specified string element</dd></dl>

</div>
</div>
<a id="a35c4cc546773ba410659bb67ea5a6c10" name="a35c4cc546773ba410659bb67ea5a6c10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35c4cc546773ba410659bb67ea5a6c10">&#9670;&nbsp;</a></span>GetTensorData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T * Ort::Value::GetTensorData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps <a class="el" href="struct_ort_api.html#a24486475cc05b9228a57b814b2024d77" title="Get a pointer to the raw data inside a tensor.">OrtApi::GetTensorMutableData</a>. </p>

</div>
</div>
<a id="a008fc5074d15a9af5a971de7dd8834ac" name="a008fc5074d15a9af5a971de7dd8834ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a008fc5074d15a9af5a971de7dd8834ac">&#9670;&nbsp;</a></span>GetTensorMutableData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T * Ort::Value::GetTensorMutableData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps <a class="el" href="struct_ort_api.html#a24486475cc05b9228a57b814b2024d77" title="Get a pointer to the raw data inside a tensor.">OrtApi::GetTensorMutableData</a>. </p>

</div>
</div>
<a id="a3fe6e43ecc5679d3e547183f36248c9d" name="a3fe6e43ecc5679d3e547183f36248c9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fe6e43ecc5679d3e547183f36248c9d">&#9670;&nbsp;</a></span>GetTensorTypeAndShapeInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ort_1_1_tensor_type_and_shape_info.html">TensorTypeAndShapeInfo</a> Ort::Value::GetTensorTypeAndShapeInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The API returns type information for data contained in a tensor. For sparse tensors it returns type information for contained non-zero values. It returns dense shape for sparse tensors. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_ort_1_1_tensor_type_and_shape_info.html" title="Wrapper around OrtTensorTypeAndShapeInfo.">TensorTypeAndShapeInfo</a></dd></dl>

</div>
</div>
<a id="a9a568ff40447e756b3a62ec7c903b45e" name="a9a568ff40447e756b3a62ec7c903b45e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a568ff40447e756b3a62ec7c903b45e">&#9670;&nbsp;</a></span>GetTypeInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ort_1_1_type_info.html">TypeInfo</a> Ort::Value::GetTypeInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The API returns type information for data contained in a tensor. For sparse tensors it returns type information for contained non-zero values. It returns dense shape for sparse tensors. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_ort_1_1_type_info.html">TypeInfo</a></dd></dl>

</div>
</div>
<a id="ac1dd63c5d27e40ef9836f276a8b94dec" name="ac1dd63c5d27e40ef9836f276a8b94dec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1dd63c5d27e40ef9836f276a8b94dec">&#9670;&nbsp;</a></span>GetValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ort_1_1_value.html">Value</a> Ort::Value::GetValue </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ort_allocator.html">OrtAllocator</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acf4d6700f1e1d961b02a39c2a43689ad" name="acf4d6700f1e1d961b02a39c2a43689ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf4d6700f1e1d961b02a39c2a43689ad">&#9670;&nbsp;</a></span>HasValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ort::Value::HasValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6db197c9c78aafe5b1a6f4e1e5d743dc" name="a6db197c9c78aafe5b1a6f4e1e5d743dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6db197c9c78aafe5b1a6f4e1e5d743dc">&#9670;&nbsp;</a></span>IsSparseTensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ort::Value::IsSparseTensor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>&lt; Return true if OrtValue contains data and returns false if the OrtValue is a None </p>
<p >Returns true if the OrtValue contains a sparse tensor </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a2df13bf81010090da46eee36c4a9b5a4" name="a2df13bf81010090da46eee36c4a9b5a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2df13bf81010090da46eee36c4a9b5a4">&#9670;&nbsp;</a></span>IsTensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ort::Value::IsTensor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if <a class="el" href="struct_ort_1_1_value.html">Value</a> is a tensor, false for other types like map/sequence/etc. </p>

</div>
</div>
<a id="a14ce9c0a1b41a61eb0f94bc9070539eb" name="a14ce9c0a1b41a61eb0f94bc9070539eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14ce9c0a1b41a61eb0f94bc9070539eb">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_ort_1_1_value.html">Value</a> &amp; Ort::Value::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ort_1_1_value.html">Value</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f8b5207913f0c484bc14ee7518ff17e" name="a8f8b5207913f0c484bc14ee7518ff17e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f8b5207913f0c484bc14ee7518ff17e">&#9670;&nbsp;</a></span>UseBlockSparseIndices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ort::Value::UseBlockSparseIndices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_ort_1_1_value_1_1_shape.html">Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>indices_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>indices_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supplies BlockSparse format specific indices and marks the contained sparse tensor as being a BlockSparse format tensor. Values are supplied with a <a class="el" href="struct_ort_1_1_value.html#a07bd3c4da603a8fc23ea6e1f86482f6b" title="This is a simple forwarding method to the other overload that helps deducing data type enum value fro...">CreateSparseTensor()</a> API. The supplied indices are not copied and the user allocated buffers lifespan must eclipse that of the OrtValue. The location of the indices is assumed to be the same as specified by OrtMemoryInfo argument at the creation time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices_shape</td><td>indices shape or a {0} for fully sparse</td></tr>
    <tr><td class="paramname">indices_data</td><td>user allocated buffer with indices or nullptr for fully spare tensors</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b6ef55a1a122063d3af38e47c340963" name="a1b6ef55a1a122063d3af38e47c340963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b6ef55a1a122063d3af38e47c340963">&#9670;&nbsp;</a></span>UseCooIndices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ort::Value::UseCooIndices </td>
          <td>(</td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>indices_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>indices_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supplies COO format specific indices and marks the contained sparse tensor as being a COO format tensor. Values are supplied with a <a class="el" href="struct_ort_1_1_value.html#a07bd3c4da603a8fc23ea6e1f86482f6b" title="This is a simple forwarding method to the other overload that helps deducing data type enum value fro...">CreateSparseTensor()</a> API. The supplied indices are not copied and the user allocated buffers lifespan must eclipse that of the OrtValue. The location of the indices is assumed to be the same as specified by OrtMemoryInfo argument at the creation time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices_data</td><td>pointer to the user allocated buffer with indices. Use nullptr for fully sparse tensors.</td></tr>
    <tr><td class="paramname">indices_num</td><td>number of indices entries. Use 0 for fully sparse tensors</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a475c1d0e4610b9ace64a71c938fd64d2" name="a475c1d0e4610b9ace64a71c938fd64d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a475c1d0e4610b9ace64a71c938fd64d2">&#9670;&nbsp;</a></span>UseCsrIndices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ort::Value::UseCsrIndices </td>
          <td>(</td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>inner_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>inner_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>outer_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>outer_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supplies CSR format specific indices and marks the contained sparse tensor as being a CSR format tensor. Values are supplied with a <a class="el" href="struct_ort_1_1_value.html#a07bd3c4da603a8fc23ea6e1f86482f6b" title="This is a simple forwarding method to the other overload that helps deducing data type enum value fro...">CreateSparseTensor()</a> API. The supplied indices are not copied and the user allocated buffers lifespan must eclipse that of the OrtValue. The location of the indices is assumed to be the same as specified by OrtMemoryInfo argument at the creation time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inner_data</td><td>pointer to the user allocated buffer with inner indices or nullptr for fully sparse tensors</td></tr>
    <tr><td class="paramname">inner_num</td><td>number of csr inner indices or 0 for fully sparse tensors</td></tr>
    <tr><td class="paramname">outer_data</td><td>pointer to the user allocated buffer with outer indices or nullptr for fully sparse tensors</td></tr>
    <tr><td class="paramname">outer_num</td><td>number of csr outer indices or 0 for fully sparse tensors</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_ort.html">Ort</a></li><li class="navelem"><a class="el" href="struct_ort_1_1_value.html">Value</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2 </li>
  </ul>
</div>
</body>
</html>
